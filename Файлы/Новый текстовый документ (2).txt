using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using static System.Math;

public class NeuralNetwork : MonoBehaviour
{

    enum MemoryMode { GET, SET }
    enum NeuronType { Hidden, Output }


    class InputLayer
    {
        private (double[], double[])[] _trainset = new (double[], double[])[]//да-да, массив кортежей из 2 массивов
        {
            (new double[]{ 0, 0 }, new double[]{ 0, 1 }),
            (new double[]{ 0, 1 }, new double[]{ 1, 0 }),
            (new double[]{ 1, 0 }, new double[]{ 1, 0 }),
            (new double[]{ 1, 1 }, new double[]{ 0, 1 })
        };
        //инкапсуляция едрид-мадрид
        public (double[], double[])[] Trainset { get => _trainset; }//такие няшные свойства нынче в C# 7
    }

    class Neuron
    {
        public Neuron(double[] inputs, double[] weights, NeuronType type)
        {
            _type = type;
            _weights = weights;
            _inputs = inputs;
        }

















        private NeuronType _type;
        private double[] _weights;
        private double[] _inputs;
        public double[] Weights { get => _weights; set => _weights = value; }
        public double[] Inputs { get => _inputs; set => _inputs = value; }
        public double Output { get => Activator(_inputs, _weights); }
        private double Activator(double[] i, double[] w)//преобразования
        {
            double sum = 0;
            for (int l = 0; l < i.Length; ++l)
                sum += i[l] * w[l];//линейные
            return Pow(1 + Exp(-sum), -1);//нелинейные
        }
        public double Derivativator(double outsignal) => outsignal * (1 - outsignal);//формула производной для текущей функции активации уже выведена в ранее упомянутой книге
        public double Gradientor(double error, double dif, double g_sum) => (_type == NeuronType.Output) ? error * dif : g_sum * dif;//g_sum - это сумма градиентов следующего слоя
    }







    private void Start()
    {
       // Play();
    }









    void Play()
    {

















        ////Neuron[,] network = new Neuron[2, 5];
        ////network[0, 0] = new Neuron();
        ////Debug.Log(network.Length);

        //////for (int i=0; i==(network.Length))

        //////int[,] network = new int[2, 2];
        //////network[0, 0] = 1;
        //////Debug.Log(network[0, 0]);
    }

    private double Sigmoid(double i)
    {
        return Round(1 / (1 + (1 / (Exp(i)))), 2);
    }
}
